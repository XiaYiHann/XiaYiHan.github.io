---
title: ZK_background
tags: 零知识证明
---

# [浅谈零知识证明：背景与起源 (qq.com)](https://mp.weixin.qq.com/s?__biz=MzUxNTgyNDk5NQ==&mid=2247484409&idx=1&sn=b29a962d1ed3bf2b322b41548f8c6bbb&chksm=f9b18ff5cec606e3afc3e6bdfcb6c4c67213d9b4b102a9a734aeb9a63879bff6a96bb00182d1&scene=21#wechat_redirect)

### 比特币网络的问题

由于比特币每一笔网络交易都是公开的，在比特币网络每一个人的交易是可以保持相对私密的，但是当一个人提现之后，由于交易所的KYC（Know Your Customer）政策，很容易被人发现这个账户的真实身份，并且被溯源到很多之前的交易。

<!--more-->

### **匿名(Anonymous) 与假名(Pseudonymous)**

匿名指的是别人永远不知道自己的信息。

假名约等于网名，虽然也有一定的私密性，但是一旦和现实生活相关之后，就会存在泄露真实身份的可能性。

### 增加隐秘性

#### CoinJoin(enample)

在同一笔交易里放入多个输入和多个输出来混淆输入输出关系，但是也不能从根本上解决，因为理论上可以不断溯源所有交易然后分析出比特币的流向，本质上任然是假名机制

![image-20231121160316013](C:\Users\12150\AppData\Roaming\Typora\typora-user-images\image-20231121160316013.png)

**Confidential Transaction（私密交易/CT）**

在假名交易的过程中，如果我们隐藏了交易的额度，那么能够解决一定的交易信息泄露

##### 同态加密：**让密文保持原有的数学特性**

假设一个加密方法***E***

- $E(a)+E(b)=E(a+b)$
- E(a)*E(b)=E(a*b)

##### Pederson Commitment （Pederson承诺）

由于$E(a)+E(b)=E(a+b)$，如下这笔交易

![image-20231121160331422](C:\Users\12150\AppData\Roaming\Typora\typora-user-images\image-20231121160331422.png)

当这笔交易广播到区块链上，所有人都可以确认交易的**输入=输出**，但是除了A和B，别人无法知道具体的交易金额

这就是**Pederson承诺**：隐藏了数据本身，但是证明了数据的关系

###### **负数漏洞**

这时候遇到一个问题，如果A付-100个币给B，然后转200个币给自己，则其他人看到的任然是$E(a)+E(b)=E(a+b)$，如果这笔交易得到节点确认，则可以疯狂印钞，导致区块链崩溃

![image-20231121160349957](C:\Users\12150\AppData\Roaming\Typora\typora-user-images\image-20231121160349957.png)

**solution**：把所有交易里的数字，都被限制在0到2^256，但是如果我透露了几个关键的交易数字，那么信息任然是不安全的

#### Target：即不能暴露原始数字，又要证明他们的特性（取值在0～2^256）

##### 所有权漏洞

因为比特币的交易与前面的交易相关，所以我们得搞清楚这笔钱A是不是真的有

把上一笔私密交易的输出当作交易的输入。这种思路有点像问题的转换，我这笔交易用上笔交易的结果，那么只要上笔交易没问题，我这笔交易也没有问题。



以太坊不需要，以太坊可以用余额机制，

提交了Pederson承诺和区间证明之外，我们额外再提供一个证明，证明交易输入的数字和原来的世界态里A的余额是相符的。我们可以用**Merkle Proof**来实现这个证明。

但是这又出现了一个新的问题，如果提交merkle proof，则告诉了别人A的输入，私密性又没了，所以我们有需要**隐藏A的余额**，但是证明**A确实有这笔钱**

##### **ZCash：**全部匿名

Pederson承诺，区间证明，Merkle证明，还有我们一直在提的黑魔法：不会暴露答案本身的证明。

### **零知识证明（zkSNARK）**

一些应用：

我们可以真正实现**去第三方的交易**。

![image-20231121160412153](C:\Users\12150\AppData\Roaming\Typora\typora-user-images\image-20231121160412153.png)

假设A在做机器学习方面的研究，但是并没有很好的电脑，于是她打算把训练模型的任务外包给B。过了三天之后，B告诉A他跑完了，需要让A先付钱再给她提供训练完的模型。A担心B并没有诚实的训练模型，而是随便生成了点随机数打了个包，所以想让B先把模型给A验证通过了再付钱。B担心A拿到模型之后偷偷抄走了模型，然后不给钱直接把他拉黑。

面对这类的问题，传统的解决方法是委托第三方，或者设计智能合约在链上来完成数据和货币的验证交换。现在有了zkSNARK，B可以直接向A提交一个模型训练的zkSNARK，证明他真的老老实实的跑了三天，并没有在作弊。A快速验证通过了之后，就可以放心的把钱打过去了。

我们可以彻底做到**数据所有权的转移**。

![image-20231121160421127](C:\Users\12150\AppData\Roaming\Typora\typora-user-images\image-20231121160421127.png)

假设银行的账户余额数据库是一个sql table，那么一亿客户就会有一亿行记录。每年银行需要花不少成本来维护这么大的数据系统。**如果每个人都可以把属于自己的那一行记录搬运到本地，自己维护自己的账户数据，那么银行一分钱都不用花。**之所以银行不去这么做，是因为用户极有可能为了利益篡改自己的数据，把100块变成100万。

zkSNARK恰恰可以保证数据本身不会有问题。我们可以构想出一个分布式银行，每个人的存款余额都存在自己的电脑里面。当A想转账给B的时候，她需要向全网提交一个证明她账上余额正确扣款的zkSNARK，这样就确保了A诚实的把转账金额从自己的余额里扣除了。B进帐的时候也会对应提交一个余额增加的zkSNARK。

我们可以把这个概念应用到所有的领域里，社交网络，银行，健康，金融审计，企业纳税，等等。通过zkSNARK，**服务提供商不需要为大量数据的存储而买单，使用者也不需要担心自己的隐私被人偷了去。**